{\rtf1\ansi\ansicpg1252\deff0\deflang1033\deflangfe1033{\fonttbl{\f0\fswiss\fprq2\fcharset0 Arial;}{\f1\fmodern\fprq1\fcharset0 Courier New;}}
{\colortbl ;\red0\green0\blue255;}
{\stylesheet{ Normal;}{\s1 heading 1;}{\s2 heading 2;}{\s3 heading 3;}}
{\*\generator Msftedit 5.41.21.2508;}\viewkind4\uc1\pard\keepn\s1\sb240\sa60\kerning32\b\f0\fs32 Media Foundation .NET v1.1\par
\pard\nowidctlpar\sb100\sa100\kerning0\b0\fs20\par
\pard The current version of this library is available at http://mfnet.SourceForge.Net and is the result of work done by:\par
{\field{\*\fldinst{HYPERLINK "mailto:snarfle@users.SourceForge.net" }}{\fldrslt{\cf1\ul snarfle@users.SourceForge.net}}}\cf0\ulnone\f0\fs20\par
\pard\nowidctlpar\sa100\par
See WhatsNew.txt for a list of what has changed since the previous version.\par
\pard\keepn\s3\sb240\sa60\b\fs26 Purpose of this library - What it is, what it isn't\par
\pard\nowidctlpar\sb100\sa100\b0\fs20 Despite the fact that Microsoft has just released a brand new interface for working with multimedia in Vista, they haven\rquote t chosen to provide access to it for managed code developers.  This library opens up MF for use in managed applications.\par
Reviewing the source code will show that there is very little executable code in this library.  There are a few helper functions, but everything else in the library is just definitions.  There isn\rquote t some large complex set of classes hidden somewhere that does the work.  Essentially, this library is a simple mapping between managed and unmanaged code.  As a result, there is little opportunity for any problems you encounter to be caused by the library.  Not zero chance, but by and large, you may expect that problems you encounter when using the library are not a result of bugs in the library (see \ldblquote Reporting bugs\rdblquote  below).\par
\pard Although there are over 100 interfaces defined in the source code, only some of them have been tested to ensure that they will work correctly (see \ldblquote Using untested interfaces\rdblquote  and \ldblquote The plan for additional interfaces\rdblquote  below).  The list of interfaces indicating which ones have been tested can be found at interaces.txt.\par
In addition to the library, a number of samples are provided showing how to use the library.  The samples are in a separate download.\par
\pard\keepn\s3\sb240\sa60\b\fs26 Licensing\par
\pard\nowidctlpar\sb100\sa100\b0\fs20 This library is licensed under GNU LESSER GENERAL PUBLIC LICENSE, Version 2.1.  See license.txt for the complete text.  I\rquote m a programmer, not a lawyer, so please, if you have questions regarding licensing, direct them to your lawyer (who undoubtedly knows more about LGPL than I do).\par
\pard\keepn\s3\sb240\sa60\b\fs26 Supported platforms, languages\fs20\par
\pard\nowidctlpar\sb100\sa100\b0 This library is usable from c#, and should work from other .NET compatible languages.  It was tested against Vista sp0 using the 2.0 .NET framework.  The library should work for both 32 bit and 64 bit versions of both Vista.\fs24\par
\pard\keepn\s3\sb240\sa60\b\fs26 Where to find the documentation\fs20\par
\pard\b0 Since the purpose of this library is to allow for the calling of the Media Foundation interfaces, the primary source of documentation is MSDN.  You can find the Media Foundation documentation at http://msdn2.microsoft.com/en-us/library/ms694197.aspx (at least until the next time Microsoft re-orgs their web site).  The few helper classes in the library are documented below in \ldblquote Helper Classes\rdblquote .\par
\pard\keepn\s3\sb240\sa60\b\fs26 Differences between MSDN docs and using this library\par
\pard\nowidctlpar\sb100\sa100\b0\fs20 It most cases, you should expect that you call the interface methods the same way MSDN says it should be called.  The primary differences between the library\rquote s definitions and those found on MSDN are related to return codes (See \ldblquote Error handling\rdblquote  below) and places where MSDN documents methods parameters as int, but then says the content of the int is some enum.  The library\rquote s definition is changed to be the enum, so Visual Studio\rquote s intelli-sense will offer up the legal values while typing code.\par
The names of the structures and enum have been changed to use a more .NET friendly style: AM_SAMPLE2_PROPERTIES -> AMSample2Properties.  Note that the original C++ structure or enum name is provided in an attribute above the declaration.  If there is some specific declaration you need to find, do a scan of the library\rquote s source files for the name.\par
\pard Also see the sections below on \ldblquote Error handling\rdblquote  and \ldblquote How and when to use Marshal.ReleaseComObject()\rdblquote .\par
\par
\b\fs26 Error handling\par
\b0\fs20 (If you are already familiar with PreserveSig and the effects it has on COM interfaces, you can skip this section.)\par
\par
Probably the main thing that will strike c++ coders and those who have worked with the c++ Media Foundation samples (or even the DirectShowNet library!) is the apparent lack of error-checking in the samples.  In c++, failing to check return codes is (rightfully!) considered sloppy programming.\par
However, things work a little differently in managed code, and trust me, error checking is being performed.  The discussion breaks down in to two parts.\par
\pard\nowidctlpar\fi-360\li720\sb100\sa100\i 1)\tab Calling COM interfaces\i0 : When you create methods on an interface (like what this library does), you can either declare them with, or without the [PreserveSig] attribute.  If you declare them \b with\b0  the attribute, then the methods will work in c# the same way they do in c++: they return an int.  Each time you call a method, you are responsible for checking to see if the call succeeded by checking the value of that int.\par
\pard\nowidctlpar\li720\sb100\sa100 However, the majority of methods in this library are declared \b without\b0  PreserveSig (or with PreserveSig(false)).  This means that .NET will check the return code for you, and turn failure codes into exceptions.  So, it isn\rquote t necessary to check the return codes after each call.  All you need to do is catch the exceptions.  You can see this in BasicPlayer Player.cs, in each of the public methods.\par
\pard\nowidctlpar\fi-360\li720\sb100\sa100\i 2)\tab Implementing COM interfaces\i0 : When you implement interfaces in c# (like the WavSource sample), you can either define the interface to return an int and return the HRESULT (ie using PreserveSig), or you can do what this library does and define them as void.  In that case, you simply throw exceptions to indicate errors.  .Net will turn them into the appropriate COM error.\par
\pard\nowidctlpar\li720\sb100\sa100 This works very well with point #1.  If the code implementing the COM object doesn\rquote t explicitly catch errors from MF calls, they get propagated up to the COM interface, turned into HRESULTs and sent back to the caller.\par
\pard\nowidctlpar\sb100\sa100 This can result in significantly cleaner code.  WavSource.cs dropped by some 400 lines (in a 2000 line program) when I changed from using HRESULTs to using exceptions.\par
\pard\keepn\s3\sb240\sa60\b\fs26 How and when to use Marshal.ReleaseComObject()\par
\pard\nowidctlpar\sb100\sa100\b0\fs20 .NET has a built-in limitation when handling COM methods.  This problem affects any .NET class calling COM, not just this library.  The problem description is rather involved, but boils down to two key facts:\par
1) Objects in .NET aren't released as soon as they go out of scope.  You have to wait for the Garbage Collector to free them.  As a result, you may get "in use" errors for items you thought should be released.  GC.Collect may help with this.  Also, you can use Marshal.ReleaseComObject.  However, that may introduce other problems (see #2).\par
2) If you create a COM object, then do \par
\pard\nowidctlpar\f1 IGraphBuilder  graphBuilder = (IGraphBuilder) new FilterGraph();\par
IMediaControl  imc = graphBuilder as IMediaControl;\par
\pard\f0 Calling Marshal.ReleaseComObject on either graphBuilder or imc will invalidate BOTH graphBuilder and imc.  For a good article on this, read Chris Brumme's weblog at http://blogs.msdn.com/cbrumme/archive/2003/04/16/51355.aspx.\par
\pard\keepn\s3\sb240\sa60\b\fs26 Helper Classes\par
\pard\nowidctlpar\sb100\sa100\b0\fs20 While the library primarily provides mappings to the Media Foundation interfaces, there are a few helper functions defined that may be useful:\par
\b PropVariant\b0  \endash  This class is a c# implementation of the PROPVARIANT structure.  It has a collection of constructors to allow creation of various forms of PROPVARIANTs, and accessors to allow reading.  \par
Note that since this is implemented as a class, there is no need to have any c# equivalent to VariantInit, and since custom marshaling is used in parameter passing, there is no need to release variants between calls to avoid leaks.  However, there is a Clear() method to ensure timely release of data should that be desirable.\par
\b ConstPropVariant\b0  \endash  This class is the parent of PropVariant.  It is used for parameters that are sent from unmanaged code where the callee (ie the managed code) should NOT clear the variant.\par
\b MFInt\b0  \endash  This class is a wrapper for ints.  The only time you should need to use this class is if you are dealing with parameters to (or from) MF that are \ldblquote out int\rdblquote , but \ldblquote can be null.\rdblquote   If you are implementing a method that has such a datatype, you will want to check the value to see if it is null, then use the Assign() method to assign a value.  See GetStreamLimits in the MFT_GrayScale sample for how this works.\par
\pard\b FourCC\b0  - This class is useful for processing 4cc (see http://msdn2.microsoft.com/en-us/library/ms783788.aspx for a discussion of some of the basics of 4 character codes).  It contains methods for converting from ints to 4cc\rquote s and Guids.\par
\par
\b COMBase\b0  \endash  This class is intended to be the parent of classes that implement COM interfaces.  It can also be used as a parent to classes that merely call COM classes, and the methods can also be called statically.  Note: There is no requirement to use this class, but it can be helpful.\par
\par
Succeeded: Checks to see if an HRESULT code is not a failure code (ie >= 0).  This isn\rquote t generally useful since most methods in the library with throw exceptions rather than returning HRESULTs.\par
\pard\nowidctlpar\sb100\sa100 Failed: Checks to see if an HRESULT code is a failure code (ie < 0).  This isn\rquote t generally useful since most methods in the library with throw exceptions rather than returning HRESULTs.\par
SafeRelease: Calls Dispose or Marshal.ReleaseComObject against objects.  Checks for null.\par
\b MFError\b0  \endash  This class contains two methods.  \par
ThrowExceptionForHR is a wrapper for Marshal.ThrowExceptionForHR, but additionally provides descriptions for any Media Foundation specific error messages.  Note that you do not have to check for negative values before calling this method.  If the hr value is not a fatal error, no exception will be thrown:\par
\pard\f1 hr = iSomething.DoSomething();\par
MFError.ThrowExceptionForHR(hr);\par
\par
\pard\nowidctlpar\sb100\sa100\f0 GetErrorText returns a string representation of HRESULTs.  This works for both Media Foundation error codes, and general COM error codes.\par
Since most of MFNet uses exceptions, if you need the HRESULT, catch the exception and use Marshal.GetHRForException().  Check out Program in the splitter sample for some code that shows this.\par
\b WaveFormatEx, WaveFormatExWithData, WaveFormatExtensible, WaveFormatExtensibleWithData\b0  \endash  C++ has this trick they do where they pass a pointer to a WaveFormatEx, then you parse the data to figure out whether the struct is really a WaveFormatEx, or a WaveFormatExtensible.  What\rquote s more, there can be some random number of bytes *after* the structure.  In order to deal with this in c# (which doesn\rquote t care for these types of shenanigans), these 4 items have been declared as classes with methods to facilitate performing this same magic for you automatically in c#.  \par
If you call a method that returns a \ldblquote WaveFormatEx,\rdblquote   you can determine if it is a WaveFormatExtensible by using the c# as operator to cast it (among other methods).\par
\b BitmapInfoHeader, BitmapInfoHeaderWithData\b0  \endash  BitmapInfoHeader has the same issues as WaveFormatEx.  See the description above.\par
\b PVMarshaler, RTIMarshaler, RTAMarshaler, GAMarshaler, WEMarshaler, BMMarshaler\b0  \endash  These classes handle the custom marshaling for PropVariants, WaveFormatEx, MFTGetInfo, MFTRegister, MFTEnum.  There should be no reason to use any of these directly.\par
\pard\keepn\s3\sb240\sa60\b\fs26 Using untested interfaces\par
\pard\nowidctlpar\sb100\sa100\b0\fs20 The MediaFoundation source code contains interfaces for virtually all of Media Foundation.  Currently, however, only some of them have been tested.  Testing includes performing each of these on each method of the interface:\par
\pard\nowidctlpar 1) Checking to see that the method is defined correctly according to the MSDN docs\par
2) Change int to enum where needed\par
3) Add any needed MarshalAs\par
4) Verify that any needed structs are correctly defined \par
5) Remove unneeded "ref", add needed "out"\par
6) (Where possible) remove IntPtr and use actual structs or classes\par
7) Where necessary, create custom marshalers for passing structs\par
8) Write code that calls the method, making sure parameters that are documented to accept null, do so\par
9) Make sure return code don\rquote t return S_* result codes or add PreserveSig\par
\pard\nowidctlpar\sb100\sa100 However, it may be that you need to use an interface that hasn't been tested yet.  All the untested interfaces, structs and enum are included in the source, but are wrapped within:\par
\pard\nowidctlpar\fi360\sb100\sa100\f1 #if ALLOW_UNTESTED_INTERFACES\par
#endif\par
\pard\nowidctlpar\sb100\sa100\f0 Release builds of the library do not expose these interfaces.  If you want to enable all the methods, you can use #define in specific source files or globally with project properties to define this constant, and then build your own copy of the library.  However, don't be surprised if some of the methods/interfaces that haven't been tested don't work correctly.  Also, when the method is eventually tested, the definition may be modified.\fs24\par
\pard\keepn\s3\sb240\sa60\b\fs26 The plan for additional interfaces\par
\pard\nowidctlpar\sb100\sa100\b0\fs20 The plan is to continue testing interfaces and moving them out of the #if.  However, no particular schedule is planned at this point.  If you have some specific methods that you would like to see tested, or if you have tested (all the methods on) an interface and would like to see it included in the library, post a message to the Open Discussion forum discussed in \ldblquote Links for help\rdblquote  below.\par
\pard\keepn\s3\sb240\sa60\b\fs26 Reporting bugs\par
\pard\b0\fs20 Bugs in this library should be reported to http://sourceforge.net/tracker/?group_id=199925&atid=971446.\par
Note that only bugs in the library, samples, or docs that are part of this project should be reported here.  Bugs in Media Foundation itself must be reported to Microsoft.\par
\pard\keepn\s3\sb240\sa60\b\fs26 Links for help\par
\pard\b0\fs20 Your best place to start is the MSDN docs (see links under "Where to find the documentation").  If your question is about Media Foundation in general, you might want to post to one of Microsoft's newsgroups (currently at http://social.msdn.microsoft.com/forums/en-US/mediafoundationdevelopment/threads/).  If your question is specific to this library, you should post your question post in the \ldblquote Open Discussion\rdblquote  forum here: http://sourceforge.net/forum/forum.php?forum_id=711229.\par
\par
\b\fs26 Errata\par
\pard\nowidctlpar\sb100\sa100\b0\fs20 The following items are minor variations between the MSDN docs and the .Net implementation.  I don\rquote t expect these to ever be an issue for anyone, but I wanted a place to keep track of them.\par
Output parameters that \ldblquote can be NULL if the value is not needed\rdblquote  present problems for .Net.  If you declare them as \ldblquote out,\rdblquote  then if someone tries to pass you a NULL, the .Net framework rejects the call.  The only way around this is to declare the parameter as IntPtr.  This is a PITA for the majority of people who just want to use the typed field, and will never try to implement an interface.  For the cases below, I don\rquote t believe the interface is intended to be implemented, only called.\par
There are a few methods on a few interfaces where the return value from the method is NOT an HRESULT.  In these cases, you must use PreserveSig to make sure the actual value can be retrieved.  It\rquote s possible that people will assume that all methods will throw an exception, and not manually throw the exception on the failure.  Doesn\rquote t seem like a big problem.  There are also a few cases where the method might return S_* error codes.  However, the status messages don\rquote t seem to be of value, so I have left the PreserveSig off for them, resulting in any potential S_ code being discarded.\par
\pard\nowidctlpar IMFSourceResolver::BeginCreateObjectFromURL cookie param can be null\par
IMFAttributes::GetString p4 can be null\par
IPropertyStore::SetValue & GetValue might return S_\par
IMFAsyncResult GetStatus & GetStateNoAddRef have preservesig\par
IMFVideoDisplayControl::SetBorderColor uses int instead of COLORREF (this is done a lot)\par
IMFMediaBuffer::Lock can accept nulls\par
IMFMediaType::IsEqual preservesig\par
MFVideoSurfaceInfo has unmarshalled array.  Custom?\par
IMFMediaEventGenerator::BeginGetEvent returns MF_S_MULTIPLE_BEGIN\par
IMFMediaTypeHandler::IsMediaTypeSupported has optional parm\par
IMFAudioMediaType::GetAudioFormat uses PreserveSig\par
IMFASFStreamConfig::GetStreamNumber uses PreserveSig\par
IMFTransform::ProcessEvent returns MF_S_TRANSFORM_DO_NOT_PROPAGATE_EVENT.  I\rquote m thinking this won\rquote t be a problem since (I believe) you can *throw* S_ codes, you just can\rquote t read them.\par
}
 